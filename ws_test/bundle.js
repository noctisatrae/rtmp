var W={connecting:0,open:1,closing:2,closed:3};var Q={closed:"closed",errored:"errored",joined:"joined",joining:"joining",leaving:"leaving"},X={close:"phx_close",error:"phx_error",join:"phx_join",reply:"phx_reply",leave:"phx_leave"},M={longpoll:"longpoll",websocket:"websocket"};class g{constructor(G,U,D,$){this.channel=G,this.event=U,this.payload=D||{},this.receivedResp=null,this.timeout=$,this.timeoutTimer=null,this.recHooks=[],this.sent=!1}resend(G){this.timeout=G,this.cancelRefEvent(),this.ref=null,this.refEvent=null,this.receivedResp=null,this.sent=!1,this.send()}send(){if(this.hasReceived("timeout"))return;this.startTimeout(),this.sent=!0,this.channel.socket.push({topic:this.channel.topic,event:this.event,payload:this.payload,ref:this.ref})}receive(G,U){if(this.hasReceived(G))U(this.receivedResp.response);return this.recHooks.push({status:G,callback:U}),this}matchReceive({status:G,response:U,ref:D}){this.recHooks.filter(($)=>$.status===G).forEach(($)=>$.callback(U))}cancelRefEvent(){if(!this.refEvent)return;this.channel.off(this.refEvent)}cancelTimeout(){clearTimeout(this.timeoutTimer),this.timeoutTimer=null}startTimeout(){if(this.timeoutTimer)return;this.ref=this.channel.socket.makeRef(),this.refEvent=this.channel.replyEventName(this.ref),this.channel.on(this.refEvent,(G)=>{this.cancelRefEvent(),this.cancelTimeout(),this.receivedResp=G,this.matchReceive(G)}),this.timeoutTimer=setTimeout(()=>{this.trigger("timeout",{})},this.timeout)}hasReceived(G){return this.receivedResp&&this.receivedResp.status===G}trigger(G,U){this.channel.trigger(this.refEvent,{status:G,response:U})}}class V{constructor(G,U,D){this.state=Q.closed,this.topic=G,this.params=U||{},this.socket=D,this.bindings=[],this.timeout=this.socket.timeout,this.joinedOnce=!1,this.joinPush=new g(this,X.join,this.params,this.timeout),this.pushBuffer=[],this.rejoinTimer=new R(()=>this.rejoinUntilConnected(),this.socket.reconnectAfterMs),this.joinPush.receive("ok",()=>{this.state=Q.joined,this.rejoinTimer.reset(),this.pushBuffer.forEach(($)=>$.send()),this.pushBuffer=[]}),this.onClose(()=>{this.rejoinTimer.reset(),this.socket.log("channel",`close ${this.topic} ${this.joinRef()}`),this.state=Q.closed,this.socket.remove(this)}),this.onError(($)=>{if(this.isLeaving()||this.isClosed())return;this.socket.log("channel",`error ${this.topic}`,$),this.state=Q.errored,this.rejoinTimer.scheduleTimeout()}),this.joinPush.receive("timeout",()=>{if(!this.isJoining())return;this.socket.log("channel",`timeout ${this.topic}`,this.joinPush.timeout),this.state=Q.errored,this.rejoinTimer.scheduleTimeout()}),this.on(X.reply,($,z)=>{this.trigger(this.replyEventName(z),$)})}rejoinUntilConnected(){if(this.rejoinTimer.scheduleTimeout(),this.socket.isConnected())this.rejoin()}join(G=this.timeout){if(this.joinedOnce)throw"tried to join multiple times. 'join' can only be called a single time per channel instance";else return this.joinedOnce=!0,this.rejoin(G),this.joinPush}onClose(G){this.on(X.close,G)}onError(G){this.on(X.error,(U)=>G(U))}on(G,U){this.bindings.push({event:G,callback:U})}off(G){this.bindings=this.bindings.filter((U)=>U.event!==G)}canPush(){return this.socket.isConnected()&&this.isJoined()}push(G,U,D=this.timeout){if(!this.joinedOnce)throw`tried to push '${G}' to '${this.topic}' before joining. Use channel.join() before pushing events`;let $=new g(this,G,U,D);if(this.canPush())$.send();else $.startTimeout(),this.pushBuffer.push($);return $}leave(G=this.timeout){this.state=Q.leaving;let U=()=>{this.socket.log("channel",`leave ${this.topic}`),this.trigger(X.close,"leave",this.joinRef())},D=new g(this,X.leave,{},G);if(D.receive("ok",()=>U()).receive("timeout",()=>U()),D.send(),!this.canPush())D.trigger("ok",{});return D}onMessage(G,U,D){return U}isMember(G){return this.topic===G}joinRef(){return this.joinPush.ref}sendJoin(G){this.state=Q.joining,this.joinPush.resend(G)}rejoin(G=this.timeout){if(this.isLeaving())return;this.sendJoin(G)}trigger(G,U,D){let{close:$,error:z,leave:B,join:F}=X;if(D&&[$,z,B,F].indexOf(G)>=0&&D!==this.joinRef())return;let I=this.onMessage(G,U,D);if(U&&!I)throw"channel onMessage callbacks must return the payload, modified or unmodified";this.bindings.filter((Z)=>Z.event===G).map((Z)=>Z.callback(I,D))}replyEventName(G){return`chan_reply_${G}`}isClosed(){return this.state===Q.closed}isErrored(){return this.state===Q.errored}isJoined(){return this.state===Q.joined}isJoining(){return this.state===Q.joining}isLeaving(){return this.state===Q.leaving}}class J{constructor(G,U={}){this.stateChangeCallbacks={open:[],close:[],error:[],message:[]},this.channels=[],this.sendBuffer=[],this.ref=0,this.timeout=U.timeout||1e4,this.transport=U.transport||window.WebSocket||O,this.heartbeatIntervalMs=U.heartbeatIntervalMs||30000,this.reconnectAfterMs=U.reconnectAfterMs||function(D){return[1000,2000,5000,1e4][D-1]||1e4},this.logger=U.logger||function(){},this.longpollerTimeout=U.longpollerTimeout||20000,this.params=U.params||{},this.endPoint=`${G}/${M.websocket}`,this.reconnectTimer=new R(()=>{this.disconnect(()=>this.connect())},this.reconnectAfterMs)}protocol(){return location.protocol.match(/^https/)?"wss":"ws"}endPointURL(){let G=Y.appendParams(Y.appendParams(this.endPoint,this.params),{vsn:"1.0.0"});if(G.charAt(0)!=="/")return G;if(G.charAt(1)==="/")return`${this.protocol()}:${G}`;return`${this.protocol()}://${location.host}${G}`}disconnect(G,U,D){if(this.conn){if(this.conn.onclose=function(){},U)this.conn.close(U,D||"");else this.conn.close();this.conn=null}G&&G()}connect(G){if(G)console&&console.log("passing params to connect is deprecated. Instead pass :params to the Socket constructor"),this.params=G;if(this.conn)return;this.conn=new this.transport(this.endPointURL()),this.conn.timeout=this.longpollerTimeout,this.conn.onopen=()=>this.onConnOpen(),this.conn.onerror=(U)=>this.onConnError(U),this.conn.onmessage=(U)=>this.onConnMessage(U),this.conn.onclose=(U)=>this.onConnClose(U)}log(G,U,D){this.logger(G,U,D)}onOpen(G){this.stateChangeCallbacks.open.push(G)}onClose(G){this.stateChangeCallbacks.close.push(G)}onError(G){this.stateChangeCallbacks.error.push(G)}onMessage(G){this.stateChangeCallbacks.message.push(G)}onConnOpen(){if(this.log("transport",`connected to ${this.endPointURL()}`,this.transport.prototype),this.flushSendBuffer(),this.reconnectTimer.reset(),!this.conn.skipHeartbeat)clearInterval(this.heartbeatTimer),this.heartbeatTimer=setInterval(()=>this.sendHeartbeat(),this.heartbeatIntervalMs);this.stateChangeCallbacks.open.forEach((G)=>G())}onConnClose(G){this.log("transport","close",G),this.triggerChanError(),clearInterval(this.heartbeatTimer),this.reconnectTimer.scheduleTimeout(),this.stateChangeCallbacks.close.forEach((U)=>U(G))}onConnError(G){this.log("transport",G),this.triggerChanError(),this.stateChangeCallbacks.error.forEach((U)=>U(G))}triggerChanError(){this.channels.forEach((G)=>G.trigger(X.error))}connectionState(){switch(this.conn&&this.conn.readyState){case W.connecting:return"connecting";case W.open:return"open";case W.closing:return"closing";default:return"closed"}}isConnected(){return this.connectionState()==="open"}remove(G){this.channels=this.channels.filter((U)=>U.joinRef()!==G.joinRef())}channel(G,U={}){let D=new V(G,U,this);return this.channels.push(D),D}push(G){let{topic:U,event:D,payload:$,ref:z}=G,B=()=>this.conn.send(JSON.stringify(G));if(this.log("push",`${U} ${D} (${z})`,$),this.isConnected())B();else this.sendBuffer.push(B)}makeRef(){let G=this.ref+1;if(G===this.ref)this.ref=0;else this.ref=G;return this.ref.toString()}sendHeartbeat(){if(!this.isConnected())return;this.push({topic:"phoenix",event:"heartbeat",payload:{},ref:this.makeRef()})}flushSendBuffer(){if(this.isConnected()&&this.sendBuffer.length>0)this.sendBuffer.forEach((G)=>G()),this.sendBuffer=[]}onConnMessage(G){let U=JSON.parse(G.data),{topic:D,event:$,payload:z,ref:B}=U;this.log("receive",`${z.status||""} ${D} ${$} ${B&&"("+B+")"||""}`,z),this.channels.filter((F)=>F.isMember(D)).forEach((F)=>F.trigger($,z,B)),this.stateChangeCallbacks.message.forEach((F)=>F(U))}}class O{constructor(G){this.endPoint=null,this.token=null,this.skipHeartbeat=!0,this.onopen=function(){},this.onerror=function(){},this.onmessage=function(){},this.onclose=function(){},this.pollEndpoint=this.normalizeEndpoint(G),this.readyState=W.connecting,this.poll()}normalizeEndpoint(G){return G.replace("ws://","http://").replace("wss://","https://").replace(new RegExp("(.*)/"+M.websocket),"$1/"+M.longpoll)}endpointURL(){return Y.appendParams(this.pollEndpoint,{token:this.token})}closeAndRetry(){this.close(),this.readyState=W.connecting}ontimeout(){this.onerror("timeout"),this.closeAndRetry()}poll(){if(!(this.readyState===W.open||this.readyState===W.connecting))return;Y.request("GET",this.endpointURL(),"application/json",null,this.timeout,this.ontimeout.bind(this),(G)=>{if(G){var{status:U,token:D,messages:$}=G;this.token=D}else var U=0;switch(U){case 200:$.forEach((z)=>this.onmessage({data:JSON.stringify(z)})),this.poll();break;case 204:this.poll();break;case 410:this.readyState=W.open,this.onopen(),this.poll();break;case 0:case 500:this.onerror(),this.closeAndRetry();break;default:throw`unhandled poll status ${U}`}})}send(G){Y.request("POST",this.endpointURL(),"application/json",G,this.timeout,this.onerror.bind(this,"timeout"),(U)=>{if(!U||U.status!==200)this.onerror(status),this.closeAndRetry()})}close(G,U){this.readyState=W.closed,this.onclose()}}class Y{static request(G,U,D,$,z,B,F){if(window.XDomainRequest){let I=new XDomainRequest;this.xdomainRequest(I,G,U,$,z,B,F)}else{let I=window.XMLHttpRequest?new XMLHttpRequest:new ActiveXObject("Microsoft.XMLHTTP");this.xhrRequest(I,G,U,D,$,z,B,F)}}static xdomainRequest(G,U,D,$,z,B,F){if(G.timeout=z,G.open(U,D),G.onload=()=>{let I=this.parseJSON(G.responseText);F&&F(I)},B)G.ontimeout=B;G.onprogress=()=>{},G.send($)}static xhrRequest(G,U,D,$,z,B,F,I){if(G.timeout=B,G.open(U,D,!0),G.setRequestHeader("Content-Type",$),G.onerror=()=>{I&&I(null)},G.onreadystatechange=()=>{if(G.readyState===this.states.complete&&I){let Z=this.parseJSON(G.responseText);I(Z)}},F)G.ontimeout=F;G.send(z)}static parseJSON(G){return G&&G!==""?JSON.parse(G):null}static serialize(G,U){let D=[];for(var $ in G){if(!G.hasOwnProperty($))continue;let z=U?`${U}[${$}]`:$,B=G[$];if(typeof B==="object")D.push(this.serialize(B,z));else D.push(encodeURIComponent(z)+"="+encodeURIComponent(B))}return D.join("&")}static appendParams(G,U){if(Object.keys(U).length===0)return G;let D=G.match(/\?/)?"&":"?";return`${G}${D}${this.serialize(U)}`}}Y.states={complete:4};class R{constructor(G,U){this.callback=G,this.timerCalc=U,this.timer=null,this.tries=0}reset(){this.tries=0,clearTimeout(this.timer)}scheduleTimeout(){clearTimeout(this.timer),this.timer=setTimeout(()=>{this.tries=this.tries+1,this.callback()},this.timerCalc(this.tries+1))}}var x=new J("ws://localhost:4000/socket");x.connect();var w=x.channel("room:ewen",{});w.join().receive("ok",(G)=>{console.log("Joined successfully!",G)}).receive("error",(G)=>{console.log("Unable to join",G)});var K={content:"Hello world!",author_id:9034905903950,created_at:5285908359,username:"noctis_atrae",channel_id:12643};w.push("new_msg",K);
